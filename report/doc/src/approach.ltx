\section{Requirements}
\label{sec:requirements}
The set of goals discussed earlier form the basis of what the requirements
for checksims should be. There is concern with checksims that certain types
of cheating may go undetected by the smith waterman algorithm. The solution
to this is to look not at the content of code submissions, but at their
structure. Creating Parsers for structured data for multiple languages is
significantly more time consuming than tokenization, but we do not have as
tight a time constraint as the previous team working on checksims. We have
also undertaken the design and implementation of more features for chechsims
in order to make it as usable as possible for course staff, including an
archiving system for comparing previous year's submissions and a user
interface to replace the command line. With our new goals in mind, we have
created a few requirements that we must meet:
\begin{itemize}
\item The program should be usable by course staff with very little
 or no training, and should produce output in a form that can be easily
 interpreted. This was a previous goal of the project which we wish to finish
 by creating a user interface.
\item Checksims should have the ability to run structure analysis on at least
 Java, C, C++, and Python. Racket is also a possibility, though not likely.
\item There should be a simple way to run checksims either remotely or on a 
 users own machine. Ideally, there should be no more than a few button presses
 for a member of the course staff to run checksims agains a closed submission.
\end{itemize}

\section{Approach}
\label{sec:approach}
The additions to checksims required some rearchitecture. The previous checksims
algorithm abstraction only allowed for tokenization based algorithms. Since
the code structure comparison based algorithms are based on trees rather than
lists, the structure of assignments required a redesign. The redesign uses
an abstraction called a ''Percentable''. Submission text can be transformed into
different types of percentables and memoized by their type. Algorithms are now
based on the percentable type on which they operate as well, and are
responsible for informing the checksims runner which type of percentable
generator they would like to have used. The new architecture should allow a
significantly broader range of algorithms to be implemented against the
underlying comparson mechanism. A description of the updated checksims pipeline
is as follows:

\begin{enumerate}
 \item Student submissions are read from the filesystem and multi-file
     submissions are concatinated into a single string of submission;
 \item submissions are then passed into a \textit{common code remover}, which
    removes code designated as ``common'' from all tokenized submissions
    to ensure it is not matched. The \textit{common code remover} is based on
    the smith-waterman algorithm, which performs superbly for exact matching
    scenarios.
 \item The percentable generator provided by the selected algorithm then
     consumes a submission and stores the parsed or tonenized form back into
     the submission for the purposes of memoization. This occurs on all
     submissions, but due to memoization, it does not happen twice.
 \item Submissions are then grouped into pairs. The selected algorithm, or
    \textit{similarity detector}, which implements a \textit{similarity
    detection algorithm}, is then run on all possible pairs of submissions, and
    the results are recorded in a \textit{similarity matrix}.
 \item The similarity matrix is then passed to a user-selected \textit{output
    strategy}, which produces a human-readable form of the output for parsing.
\end{enumerate}
