\section{Existing Literature}
A large portion of the work done is based on the work put forth in the
original \textit{Checksims} paper. This includes not only the code that was
produced in that project, but also the definitions and literature review that
was conducted. Many of the definitions and terms discussed from here on can be
directly attributed to their work.

\subsection{Academic Dishonesty}
The original \textit{Checksims} authors provided a comprehensive set of
examples and scenarios where academic dishonesty is the hardest to
distinguish. As they noted, an instance of ``100\% similarity was almost
certainly indicitive of unauthorized copying''\cite{checksims1}, but there are
many scenarios where determining whether a submission constitutes dishonest
behavior is not as simple.
% Throw in a few papers here, discuss various standards.

\subsection{Detecting Academic Dishonesty}
There have been numerous approaches to detecting duplicate code. Primarily,
researchers attempt to identify academic dishonesty, duplicated code in
codebases, or copyright infringement in various contexts. While different
goals, these methods share the same task: to identify duplicated code while
handling minor obfuscation tactics. This section discusses the types of
identification methods and particular methods discovered while reviewing
existing literature.

\subsubsection{Detection of Dishonesty using Body Text}
The original \textit{Checksims} paper thoroughly reviews a number of existing
methods of identifying duplicate code. As \textit{Checksims} was dedicated
to language independent identification, it did not discuss syntax tree based
methods.

\subsubsection{Detection of Dishonesty using Syntax Trees}
As was again mentioned in the original \textit{Checksims} paper, detecting
academic dishonesty in programming assignments is significantly easier than
detecting dishonesty in natural language due to the fact that programming
languages follow grammars which are significantly simpler than natural written
language. Consider the grammar for the LISP family of programming languages;
in the grammar definition syntax of ANTLR, a lisp program would be defined as
the following:

\begin{lstlisting}
COMMENT : \;.*\n -> skip
ID : [a-zA-Z0-9]+

sExpr :
    '(' (ID | sExpr)+ ')'
\end{lstlisting}

Written long hand, this grammar states that any block of text between a
semicolon (;) character and a newline (\textbackslash n) character is
considered a comment and can be skipped for the purpose of parsing. An ``ID''
consists of any arrangement of the characters a--z, A--Z, and 0--9, and than an ``sExpr'' consists of at least 1 child, where each child is either an ID or
an sExpr.

This grammar definition shows that LISP languages are just textual
representations of an N-dimensional tree, with IDs as leaf nodes and sExprs as
branch nodes. The difficulty of detecting dishonesty by transforming text into
an AST is that if the submitted text does not correctly implement the expected
grammar, a tree cannot be generated and comparison cannot happen. This is
surprisingly common in student submissions for a class --- real world examples
used for testing show that about 2 to 4 percent of code submissions are not
valid for the language in which they are written.

% Throw in methods here from various papers.
